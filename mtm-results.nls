;; ----------------------------------------------------------------------------
;; Extensible model results output
;; ----------------------------------------------------------------------------

;; initialise a results table with a bunch of empty lists of lists
to setup-results-tables
  set results table:make
  table:put results "income_costs"  table:from-list (map list (list "income" "costs" "debt") n-values 3 [i -> []]) 
  table:put results "interventions" table:from-list (map list mgmt-intervention-types        n-values length mgmt-intervention-types [i -> []]) 
  table:put results "landuse"       table:from-list (map list farm-types                     n-values length farm-types [i -> []])
  table:put results "env_metrics"   table:from-list (map list table:keys env-metrics         n-values length table:keys env-metrics [i -> []])
end


;; reset results table to only the first item in each list
to reset-results-tables
  foreach table:values results [ tbl ->
    foreach table:keys tbl [ k ->
      let reset-time-series sublist table:get tbl k 0 1
      table:put tbl k reset-time-series
    ]
  ]
end


;; delegate details of updating each subset of data to its own procedure
to update-model-results
  update-income-costs-debt-results
  update-interventions-results
  update-landuse-results
  update-metrics-results
end


;; aggregate income, costs, and debt of farms
to update-income-costs-debt-results
  let time-series table:get table:get results "income_costs" "income"
  set time-series lput sum [current-income] of farms time-series
  table:put table:get results "income_costs" "income" time-series

  set time-series table:get table:get results "income_costs" "costs"
  set time-series lput sum [current-costs] of farms time-series
  table:put table:get results "income_costs" "costs" time-series

  set time-series table:get table:get results "income_costs" "debt"
  set time-series lput sum [current-debt] of farms time-series
  table:put table:get results "income_costs" "debt" time-series
end


;; proportions of land on which various interventions have been implemented
to update-interventions-results
  (foreach range length mgmt-intervention-types [ i ->
    let intervention item i mgmt-intervention-types
    let time-series table:get table:get results "interventions" intervention
    set time-series lput sum [count the-land] of holdings with [matrix:get my-interventions 0 i = 1] time-series
    table:put table:get results "interventions" intervention time-series
  ])
end


;; proportions of land in each landuse
to update-landuse-results
  foreach farm-types [ ft ->
    let time-series table:get table:get results "landuse" ft
    set time-series lput count farm-land with [landuse = ft] time-series
    table:put table:get results "landuse" ft time-series
  ]
end

;; proportion of farms in breach of environmental limits
to update-metrics-results
  let e-metrics sort table:keys env-metrics
  foreach range length e-metrics [ i ->
    let metric item i e-metrics
    let time-series table:get table:get results "env_metrics" metric
    set time-series lput (count farms with [in-breach? item i e-metrics] / count farms) time-series
    table:put table:get results "env_metrics" metric time-series
  ]
end


;; generates a base pathname + filename based on date and time
to-report results-base-filename
  let dt-elements split-string date-and-time " "                      ;; e.g., ["02:14:00.360" "pm" "21-Aug-2025"]
  let dt join-string (list
    join-string reverse split-string item 2 dt-elements "-" "-"       ;;        "21-Aug-2025"  -> "2025-Aug-21"
    str-replace item 0  split-string item 0 dt-elements "." ":" "-"   ;;        "02:14:00.360" -> "02-14-00"
    item 1 dt-elements                                                ;;        "pm"
  ) "-"                                                               ;;        "2025-Aug-21-02-14-00-pm"
  report (word output-data-folder "/" experiment-name "/results-" dt)
end


;; outputs two files
;; <somename>-header.csv containing the parameter settings, and
;; <somename>.csv with the time series as recorded in the results table
to output-results
  let basename results-base-filename
  let header-fname (word basename "-header.csv")
  carefully [
    file-open header-fname
    file-print results-header
    file-close
  ]
  [
    print (list "Failed to write results header file to " header-fname)
    stop
  ]
  let results-fname (word basename ".csv")
  ;; make up a list of the key-pairs in the results table
  let keys []
  foreach table:keys results [ k1 ->
    foreach table:keys (table:get results k1) [ k2 ->
      set keys lput (list k1 k2) keys
    ]
  ] 
  carefully [
    file-open results-fname
    ;; write header of key1_key2 for each variable in the results table
    file-print csv:to-row (sentence "tick" (map [k -> join-string k "_"] keys))
    foreach range ticks [ t ->
      let line (list t)
      foreach keys [ k ->
        let [k1 k2] k
        set line lput item t (table:get (table:get results k1) k2) line
      ]
      file-print csv:to-row line
    ]
    file-close
  ]
  [
    print (word "Failed to write results to " results-fname)
    stop
  ]
end


to-report results-header
  report csv:to-string (list 
    (list "parameter_name"               "value")
    (list "run-seed"                     run-seed)
    (list "geography-seed"               geography-seed)
    (list "output_data_folder"           output-data-folder)
    (list "market_data_folder"           market-data-folder)
    (list "spatial_data_folder"          spatial-data-folder) 
    (list "geography_from_files"         geography-from-files?)
    (list "scenario"                     scenario)
    (list "region"                       region)
    (list "LUC_aggregation_steps"        luc-aggregation-steps)
    (list "number_of_farms"              number-of-farms)
    (list "correlated_landuse"           correlated-landuse?)
    (list "landuse_aggregation_steps"    landuse-aggregation-steps)
    (list "include_networks"             include-networks?)
    (list "n_local_links"                n-local-links)
    (list "n_catchment_links"            n-catchment-links)
    (list "rel_weight_locals"            rel-weight-locals)
    (list "rel_weight_catchment"         rel-weight-catchment)
    (list "interest_rate"                interest-rate)
    (list "sigmoid_slope"                sigmoid-slope)
    (list "landuse_change_on_succession" landuse-change-on-succession?)
    (list "prioritise_forestry"          prioritise-forestry?)
    (list "apply_severity_of_losses"     apply-severity-of-losses?)
    (list "apply_suitability"            apply-suitability?)
    (list "include_debt"                 include-debt?)
  )
end


;; The MIT License (MIT)
;;
;; Copyright (c) 2023-25 David O'Sullivan
;;
;; Permission is hereby granted, free of charge, to any person
;; obtaining a copy of this software and associated documentation
;; files (the "Software"), to deal in the Software without restriction,
;; including without limitation the rights to use, copy, modify, merge,
;; publish, distribute, sublicense, and/or sell copies of the Software,
;; and to  permit persons to whom the Software is furnished to do so,
;; subject to the following conditions:
;;
;; The above copyright notice and this permission notice shall be included
;; in all copies or substantial portions of the Software.
;;
;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
;; OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
;; THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
;; FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;; DEALINGS IN THE SOFTWARE.

